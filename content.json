{"meta":{"title":"博客","subtitle":null,"description":null,"author":"ci","url":"http://yoursite.com"},"pages":[{"title":"java helloworld程序","date":"2018-08-19T07:52:09.000Z","updated":"2018-08-19T09:05:05.288Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"java入门程序12345public class Main(String[] args)&#123; public static void main()&#123; System.out.println(\"helloworld\"); &#125;&#125;"},{"title":"tags","date":"2018-08-19T08:29:29.000Z","updated":"2018-08-19T08:29:54.087Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"java算法项目（二）快速排序","slug":"2","date":"2018-08-30T12:44:34.000Z","updated":"2018-08-30T13:03:14.580Z","comments":true,"path":"2018/08/30/2/","link":"","permalink":"http://yoursite.com/2018/08/30/2/","excerpt":"","text":"快速排序是一种既不浪费空间又可以快一点的排序算法，快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：选定数组中一个数作为基数，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比基数小，另外一部分的所有数据都比基数大，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 如图演示： 将剩下的两部分继续递归运算，最终将得到一个有序序列。 快速排序的时间复杂度在最坏情况下是O(N2)，平均的时间复杂度是O(N*lgN)。 快速排序实现代码QuickSort.java: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package algorithm.impl;import algorithm.SortService;import org.springframework.stereotype.Component;@Component(\"QuickSort\")public class QuickSort implements SortService &#123; @Override public void sort(double[] input) &#123; quickSort(input,0,input.length-1); for(double d:input)&#123; System.out.println(d); &#125; &#125; /** * * @param array 需要排序的数组 * @param left 最左边数字下标 * @param right 最右边数字下标 */ private void quickSort(double[] array,int left,int right)&#123; //最左边小标等于最右边下标时，跳出递归 if(left==right)&#123; return; &#125; int i=left; int j=right; double base=array[left]; for(;j&gt;i;j--)&#123; if(array[j]&lt;base)&#123; for(;i&lt;j;i++)&#123; if(array[i]&gt;base)&#123; double temp=array[i]; array[i]=array[j]; array[j]=temp; break; &#125; &#125; &#125; if(i==j)&#123; break; &#125; &#125; double temp=base; array[left]=array[j]; array[j]=temp; //如果i==最左边下标时，跳出递归 if(left!=i)&#123; quickSort(array,left,i-1); &#125; if(right!=i)&#123; quickSort(array,i+1,right); &#125; &#125;&#125; 测试代码SortTest.java: 12345678910111213141516171819202122232425package test;import algorithm.SortService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import proxy.RunProxy;import utils.RandomUtils;import javax.annotation.Resource;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class SortTest &#123; //所有排序类都实现了SortService接口，通过指定Bean Name通过spring注入 @Resource(name=\"QuickSort\") private SortService sortService; @Test public void test1()&#123; double[] randomNum = RandomUtils.getRandomNum(500, 1000, 10000); SortService sortServiceProxy = new RunProxy(this.sortService).getSortService(); sortServiceProxy.sort(randomNum); &#125;&#125; 测试结果为： 排序10000个数字用时95ms，而冒泡排序需要270+ms，可见快速排序的优势。","categories":[],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://yoursite.com/tags/数据结构和算法/"}]},{"title":"java算法项目（一）环境部署","slug":"1","date":"2018-08-28T00:32:00.000Z","updated":"2018-08-29T06:30:34.216Z","comments":true,"path":"2018/08/28/1/","link":"","permalink":"http://yoursite.com/2018/08/28/1/","excerpt":"","text":"算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰，算法代表着用系统的方法描述解决问题的策略机制。好的算法能让运算数据成指数减少，此项目为基本排序算法项目的搭建，输入数组排序并计算运行时间。 项目结构为： 使用spring框架实现排序类的自动注入。 SortService.java排序接口： 123456package algorithm;//定义排序接口，所有排序类继承该接口，以便通过多态实现计时代理类和spring注入public interface SortService &#123; void sort(double[] input);&#125; 所有的排序类都实现该接口，如冒泡排序类BubbleSort.java: 1234567891011121314151617181920212223242526package algorithm.impl;import algorithm.SortService;import org.springframework.stereotype.Component;/** * 冒泡排序 */@Component(\"BubbleSort\")public class BubbleSort implements SortService &#123; @Override public void sort(double[] input) &#123; for(int i=0;i&lt;input.length-1;i++)&#123; for(int j=0;j&lt;input.length-i-1;j++)&#123; if (input[j] &gt; input[j+1])&#123; double temp=input[j+1]; input[j+1]=input[j]; input[j]=temp; &#125; &#125; &#125; for(double d:input)&#123; System.out.println(d); &#125; &#125;&#125; 通过spring配置包扫描，配置@Component(name=”BubbleSort”)注解为Bean指定Name属性，然后在测试类中注入，如下：SortTest.java: 12345678910111213141516171819202122232425package test;import algorithm.SortService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import proxy.RunProxy;import utils.RandomUtils;import javax.annotation.Resource;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class SortTest &#123; //所有排序类都实现了SortService接口，通过指定Bean Name通过spring注入 @Resource(name=\"BubbleSort\") private SortService sortService; @Test public void test1()&#123; double[] randomNum = RandomUtils.getRandomNum(500, 1000, 10000); SortService sortServiceProxy = new RunProxy(this.sortService).getSortService(); sortServiceProxy.sort(randomNum); &#125;&#125; 排序计时的动态代理类为RunProxy.java: 123456789101112131415161718192021222324252627282930313233package proxy;import algorithm.SortService;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * 排序计时动态代理类 */public class RunProxy implements InvocationHandler &#123; private SortService sortService; public RunProxy(SortService sortService)&#123; this.sortService=sortService; &#125; public SortService getSortService()&#123; SortService sortServiceProxy= (SortService) Proxy.newProxyInstance(sortService.getClass().getClassLoader(),sortService.getClass().getInterfaces(),this); return sortServiceProxy; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; long start = System.currentTimeMillis(); Object o = method.invoke(sortService, args); long end=System.currentTimeMillis(); System.out.println(\"算法使用时间：\"+(end-start)+\"ms\"); return o; &#125;&#125; 获得随机数组的工具类RandomUtis.java: 123456789101112131415161718192021package utils;/** * 获得随机数值的工具类 */public class RandomUtils &#123; /** * * @param start 取值下限 * @param end 取值的上限 * @param num 数值的长度 * @return 随机数组 */ public static double[] getRandomNum(double start,double end,int num)&#123; double[] array=new double[num]; for(int i=0;i&lt;num;i++)&#123; array[i]=Math.random()*(end-start)+start; &#125; return array; &#125;&#125; 运行测试类结果如下： 测试成功","categories":[],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://yoursite.com/tags/数据结构和算法/"}]},{"title":"java helloworld程序","slug":"hello","date":"2018-08-19T07:52:09.000Z","updated":"2018-08-19T09:05:00.637Z","comments":true,"path":"2018/08/19/hello/","link":"","permalink":"http://yoursite.com/2018/08/19/hello/","excerpt":"","text":"java入门程序12345public class Main(String[] args)&#123; public static void main()&#123; System.out.println(\"helloworld\"); &#125;&#125;","categories":[],"tags":[{"name":"11","slug":"11","permalink":"http://yoursite.com/tags/11/"}]}]}